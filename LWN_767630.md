# LWN 767630 當 CPU 沒事可做時它會做什麼？(What's a CPU to do when it has nothing to do?)

[原文出處](https://lwn.net/Articles/767630/)

translated by<`RanceJen`>

Ongoing

> It would be reasonable to expect doing nothing to be an easy, simple task for a kernel, but it isn't. At Kernel Recipes 2018, Rafael Wysocki discussed what CPUs do when they don't have anything to do, how the kernel handles this, problems inherent in the current strategy, and how his recent rework of the kernel's idle loop has improved power consumption on systems that aren't doing anything.

一般理論上都會認為對於 kernel 來說不做任何事是非常簡單和單純的，但其實不然。在 Kernel Recipes 2018 上 Rafael Wysocki 就談論到了當 CPU 沒事可做時它會做什麼和 kernel 如何處理這件事。在目前的處理策略上的問題，以及在最近他如何對於 Kernel 的 idle loop 做改動來增進其在閒置時的能源使用效率。

> The idle loop, one of the kernel subsystems that Wysocki maintains, controls what a CPU does when it has no processes to run. Precise to a fault, Wysocki defined his terms: for the purposes of this discussion, a CPU is an entity that can take instructions from memory and execute them at the same time as any other entities in the same system are doing likewise. On a simple, single-core single-processor system, that core is the CPU. If the processor has multiple cores, each of those cores is a CPU. If each of those cores exposes multiple interfaces for simultaneous instruction execution, which Intel calls "hyperthreading", then each of those threads is a CPU. 

idle loop 是由 Wysocki 負責維護的 kernel 子系統之一，負責控制 CPU 在無 processes 要運行時的行為，Wysocki 在本次的討論中精確說明 CPU 是一個實體可以將 instruction 從 memory 取出並且執行，且在同個時間內其他的實體也在執行相同的事情。在一個簡單的單 core 單 processor 系統上，該 core 即為 CPU。如果今天 processor 有多個 core ，則每個 core 都是一個 CPU，如果在每個 core 上都可以拆出不同的 interfaces 去同時運行 instruction，也就是 Intel 所謂的 hyperthreading ，則其上的每個 thread 都是一個 CPU 。

> A CPU is idle if there are no tasks for it to run. Or, again more precisely, the Linux kernel has a number of internal scheduling classes, including the special idle class. If there are no tasks to run on a given CPU in any of those classes save the idle class, the CPU is regarded as idle. If the hardware doesn't make allowance for this, then the CPU will have to run useless instructions until it is needed for real work. However, this is a wildly inefficient use of electricity, so most CPUs support a number of lower-power states into which the kernel can put them until they are needed to do useful work. 

當沒有 task 要執行的時候 CPU 就是閒置的，更精確的說明一下，在 Linux kernel 內其實有許多不同的排程型態，像是特別的閒置型態，如果在特定 CPU 上除了 idle class 之外沒有任何排程有 tasks 要運行，則這個就被認為是閒置的，如果硬體沒有考慮到這點，則 CPU 會不斷執行無用的 instructions 直到真的有工作需要其執行，然而這其實是一種很沒效率的用電方式，所以所以大部分的 CPU 都會支援數種不同的省電模式讓 kernel 可以設置直到真的有工作需要做的時候。

> Idle states are not free to enter or exit. Entry and exit both require some time, and moreover power consumption briefly rises slightly above normal for the current state on entry to idle and above normal for the destination state on exit from idle. Although increasingly deep idle states consume decreasing amounts of power, they have increasingly large costs to enter and exit. This implies that for short idle periods, a fairly shallow idle state is the best use of system resources; for longer idle periods, the costs of a deeper idle state will be justified by the increased power savings while idle. It is therefore in the kernel's best interests to predict how long a CPU will be idle before deciding how deeply to idle it. This is the job of the idle loop. 

進入或離開閒置狀態並非沒有成本的，切入跟切出兩者都會需要一些時間，在進入以及離開 idle 狀態時也會略為增加耗電量，所以其實在切入和切出時都有相當大的成本。這暗示了在較短的 idle 期間，較淺的 idle 狀態會是更好的，而在 idle 越久省下能源相較於的深層 idle 狀態的切換成本才會比較合理，所以 kernel 本身最在意的其實是在預測 CPU 會閒置多久來決定要進入多深的 idle 狀態，這就是 idle loop 的工作。

> In this loop, the CPU scheduler notices that a CPU is idle because it has no work for the CPU to do. The scheduler then calls the governor, which does its best to predict the appropriate idle state to enter. There are currently two governors in the kernel, called "menu" and "ladder". They are used in different cases, but they both try to do roughly the same thing: keep track of system state when a CPU idles and how long it ended up idling for. This is done in order to predict how long a freshly-idle CPU is likely to remain so, and thus what idle state is most appropriate for it. 

在這個迴圈中， CPU scheduler 會注意到 CPU 正在閒置因為目前沒有任何事要做，然後這個 scheduler 就會去呼叫 governor ，他會盡可能的去預測哪種 idle 狀態是適合切入的，在 kernel 中有兩種 governor 分別是 menu 和 ladder ，他們兩個是在不同情況下使用的，但基本上做的事情是一樣的，就是持續追蹤系統的狀態及閒置狀態最後保持了多久，做這些是為了預測接下來的 CPU idle 會保持多久，因此那一種 idle 狀態是最適合的。

> This job is made particularly difficult by the CPU scheduler's clock tick. This is a timer that is run by CPU scheduler for purpose of time-sharing the CPU: if you're going to run multiple jobs on a single CPU, each job can only be run for a while, then periodically put aside in favor of another job. This tick doesn't need to run on a CPU that is idle,since there are no jobs between which the CPU should be shared. Moreover, if the tick is allowed to run on an otherwise-idle CPU, it will prevent the governor from selecting deep idle states by limiting the time for which the CPU is likely to remain idle. So in kernels 4.16 and older,the scheduler disables the tick before calling the governor. When the CPU is woken by an interrupt, the scheduler makes a decision about whether there's work to do and, if so,reactivates the tick.

這像工作的特別困難之處在於 CPU scheduler 的 clock tick ， clock tick 是 CPU scheduler 執行的一個計時器，用於 time-sharing 的處理上，如果今天要在單 CPU 運行多個任務時，個別任務一次只能持續執行一陣子，然後要定期切換到其他的任務。這個計時器在閒置狀態時是不必要的，因為根本沒有任務要執行故不用分享 CPU ，此外如果允許這個計時器執行在 idle 的 CPU 上，他會阻止 governor 去選擇深層的 idle 狀態，因為 CPU 每次能閒置的時間有限。所以在 kernel 4.16 跟更舊的版本上，scheduler 會先禁用 clock tick 再來調用 governor，而當 CPU 被 interrupt 喚醒時，scheduler 會決定是否有任務要做，如果有任務的話再來啟用 clock tick 。

> 註：在發表上有提到為什麼 clock tick 會使 CPU 每次能閒置的時間有限，因為 clock tick 本身是一個切換 CPU 用的計時器，所以每次時間到就會叫醒 CPU ，那閒置就會被瘋狂的打斷。